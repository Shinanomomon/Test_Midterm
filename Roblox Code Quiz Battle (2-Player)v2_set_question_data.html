<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Roblox Code Quiz Battle (Phaser 3)</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap');
    body {
      margin: 0;
      background: #87ceeb; /* Sky Blue Background */
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      font-family: 'Poppins', sans-serif;
    }
    #game-container {
      border-radius: 12px;
      overflow: hidden;
      border: 4px solid #333;
      box-shadow: 0 10px 20px rgba(0,0,0,0.2);
    }
  </style>
</head>
<body>
  <div id="game-container"></div>

<script>
// --- CONSTANTS ---
const GAME_WIDTH = 1024;
const GAME_HEIGHT = 620;

// --- NEW DATABASE QUESTIONS (THAI) ---
const QUESTIONS = [
  // Topic 1: Concepts & DBMS
  { q: "à¸à¸²à¸™à¸‚à¹‰à¸­à¸¡à¸¹à¸¥ (Database) à¸„à¸·à¸­à¸­à¸°à¹„à¸£?", choices: ["à¹‚à¸›à¸£à¹à¸à¸£à¸¡à¸„à¸³à¸™à¸§à¸“", "à¸—à¸µà¹ˆà¹€à¸à¹‡à¸šà¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸­à¸¢à¹ˆà¸²à¸‡à¹€à¸›à¹‡à¸™à¸£à¸°à¸šà¸š", "à¸£à¸°à¸šà¸šà¸›à¸à¸´à¸šà¸±à¸•à¸´à¸à¸²à¸£", "à¹€à¸§à¹‡à¸šà¹€à¸šà¸£à¸²à¸§à¹Œà¹€à¸‹à¸­à¸£à¹Œ"], answer: 1, difficulty: 'easy' }, // 0.5
  { q: "DBMS à¸¢à¹ˆà¸­à¸¡à¸²à¸ˆà¸²à¸à¸­à¸°à¹„à¸£?", choices: ["Data Building Management", "Database Management System", "Data Backup Master", "Database Modify Standard"], answer: 1, difficulty: 'easy' }, // 0.5
  { q: "à¸‚à¹‰à¸­à¹ƒà¸” *à¹„à¸¡à¹ˆà¹ƒà¸Šà¹ˆ* à¸«à¸™à¹‰à¸²à¸—à¸µà¹ˆà¸‚à¸­à¸‡ DBMS?", choices: ["à¸ˆà¸±à¸”à¸à¸²à¸£à¸„à¸§à¸²à¸¡à¸›à¸¥à¸­à¸”à¸ à¸±à¸¢", "à¸ªà¸³à¸£à¸­à¸‡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥", "à¹€à¸‚à¸µà¸¢à¸™à¹‚à¸›à¸£à¹à¸à¸£à¸¡à¹à¸­à¸›à¸žà¸¥à¸´à¹€à¸„à¸Šà¸±à¸™", "à¸„à¸§à¸šà¸„à¸¸à¸¡à¸à¸²à¸£à¹€à¸‚à¹‰à¸²à¸–à¸¶à¸‡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥"], answer: 2, difficulty: 'medium' }, // 1
  { q: "\"à¸£à¸°à¸šà¸šà¸ˆà¸±à¸”à¸à¸²à¸£à¸à¸²à¸™à¸‚à¹‰à¸­à¸¡à¸¹à¸¥\" (DBMS) à¸•à¹ˆà¸²à¸‡à¸ˆà¸²à¸ \"à¸à¸²à¸™à¸‚à¹‰à¸­à¸¡à¸¹à¸¥\" (Database) à¸­à¸¢à¹ˆà¸²à¸‡à¹„à¸£?", choices: ["DBMS à¸„à¸·à¸­à¸‚à¹‰à¸­à¸¡à¸¹à¸¥, Database à¸„à¸·à¸­à¹‚à¸›à¸£à¹à¸à¸£à¸¡", "DBMS à¸„à¸·à¸­à¹‚à¸›à¸£à¹à¸à¸£à¸¡, Database à¸„à¸·à¸­à¸—à¸µà¹ˆà¹€à¸à¹‡à¸šà¸‚à¹‰à¸­à¸¡à¸¹à¸¥", "à¸—à¸±à¹‰à¸‡à¸ªà¸­à¸‡à¸­à¸¢à¹ˆà¸²à¸‡à¹€à¸«à¸¡à¸·à¸­à¸™à¸à¸±à¸™", "Database à¹ƒà¸Šà¹‰à¹€à¸à¹‡à¸šà¹„à¸Ÿà¸¥à¹Œ, DBMS à¹ƒà¸Šà¹‰à¸£à¸±à¸™"], answer: 1, difficulty: 'medium' }, // 1

  // Topic 2: Relational Design
  { q: "\"Relational Database\" (à¸à¸²à¸™à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¹€à¸Šà¸´à¸‡à¸ªà¸±à¸¡à¸žà¸±à¸™à¸˜à¹Œ) à¹€à¸à¹‡à¸šà¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¹ƒà¸™à¸£à¸¹à¸›à¹à¸šà¸šà¹ƒà¸”?", choices: ["à¹„à¸Ÿà¸¥à¹Œ Text", "à¸•à¸²à¸£à¸²à¸‡ (Table)", "à¸£à¸¹à¸›à¸ à¸²à¸ž", "à¹‚à¸Ÿà¸¥à¹€à¸”à¸­à¸£à¹Œ"], answer: 1, difficulty: 'easy' }, // 0.5
  { q: "\"Primary Key\" (à¸„à¸µà¸¢à¹Œà¸«à¸¥à¸±à¸) à¸„à¸·à¸­à¸­à¸°à¹„à¸£?", choices: ["à¸„à¸­à¸¥à¸±à¸¡à¸™à¹Œà¸—à¸µà¹ˆà¸£à¸°à¸šà¸¸à¹€à¸­à¸à¸¥à¸±à¸à¸©à¸“à¹Œà¸‚à¸­à¸‡à¹à¸–à¸§", "à¹à¸–à¸§à¹à¸£à¸à¸‚à¸­à¸‡à¸•à¸²à¸£à¸²à¸‡", "à¸Šà¸·à¹ˆà¸­à¸•à¸²à¸£à¸²à¸‡", "à¸Šà¸·à¹ˆà¸­à¸à¸²à¸™à¸‚à¹‰à¸­à¸¡à¸¹à¸¥"], answer: 0, difficulty: 'easy' }, // 0.5
  { q: "\"Foreign Key\" (à¸„à¸µà¸¢à¹Œà¸™à¸­à¸) à¹ƒà¸Šà¹‰à¸—à¸³à¸­à¸°à¹„à¸£?", choices: ["à¹ƒà¸Šà¹‰à¸£à¸°à¸šà¸¸à¹€à¸­à¸à¸¥à¸±à¸à¸©à¸“à¹Œ", "à¹ƒà¸Šà¹‰à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¹‚à¸¢à¸‡à¸•à¸²à¸£à¸²à¸‡", "à¹ƒà¸Šà¹‰à¹€à¸£à¸µà¸¢à¸‡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥", "à¹ƒà¸Šà¹‰à¸„à¸³à¸™à¸§à¸“"], answer: 1, difficulty: 'medium' }, // 1
  { q: "\"Normalization\" (à¸à¸²à¸£à¸—à¸³à¹ƒà¸«à¹‰à¹€à¸›à¹‡à¸™à¸šà¸£à¸£à¸—à¸±à¸”à¸à¸²à¸™) à¸¡à¸µà¸›à¸£à¸°à¹‚à¸¢à¸Šà¸™à¹Œà¸«à¸¥à¸±à¸à¸­à¸¢à¹ˆà¸²à¸‡à¹„à¸£?", choices: ["à¹€à¸žà¸´à¹ˆà¸¡à¸„à¸§à¸²à¸¡à¹€à¸£à¹‡à¸§", "à¸¥à¸”à¸„à¸§à¸²à¸¡à¸‹à¹‰à¸³à¸‹à¹‰à¸­à¸™à¸‚à¸­à¸‡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥", "à¹€à¸žà¸´à¹ˆà¸¡à¸‚à¸™à¸²à¸”à¸à¸²à¸™à¸‚à¹‰à¸­à¸¡à¸¹à¸¥", "à¸—à¸³à¹ƒà¸«à¹‰à¸„à¹‰à¸™à¸«à¸²à¸Šà¹‰à¸²à¸¥à¸‡"], answer: 1, difficulty: 'hard' }, // 1.5

  // Topic 3: Tables & Relationships
  { q: "\"Schema\" (à¸ªà¸„à¸µà¸¡à¸²) à¸‚à¸­à¸‡à¸à¸²à¸™à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸«à¸¡à¸²à¸¢à¸–à¸¶à¸‡à¸­à¸°à¹„à¸£?", choices: ["à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¹ƒà¸™à¸•à¸²à¸£à¸²à¸‡", "à¹‚à¸„à¸£à¸‡à¸ªà¸£à¹‰à¸²à¸‡à¸‚à¸­à¸‡à¸à¸²à¸™à¸‚à¹‰à¸­à¸¡à¸¹à¸¥", "à¸£à¸«à¸±à¸ªà¸œà¹ˆà¸²à¸™", "à¹‚à¸›à¸£à¹à¸à¸£à¸¡ DBMS"], answer: 1, difficulty: 'medium' }, // 1
  { q: "à¸„à¸§à¸²à¸¡à¸ªà¸±à¸¡à¸žà¸±à¸™à¸˜à¹Œà¹à¸šà¸š \"One-to-Many\" (à¸«à¸™à¸¶à¹ˆà¸‡à¸•à¹ˆà¸­à¸à¸¥à¸¸à¹ˆà¸¡) à¸„à¸·à¸­à¸‚à¹‰à¸­à¹ƒà¸”?", choices: ["à¸™à¸±à¸à¹€à¸£à¸µà¸¢à¸™ 1 à¸„à¸™ à¸¡à¸µ 1 à¸£à¸«à¸±à¸ª", "1 à¹à¸œà¸™à¸ à¸¡à¸µà¸žà¸™à¸±à¸à¸‡à¸²à¸™à¸«à¸¥à¸²à¸¢à¸„à¸™", "à¸™à¸±à¸à¹€à¸£à¸µà¸¢à¸™à¸«à¸¥à¸²à¸¢à¸„à¸™ à¸¥à¸‡à¸—à¸°à¹€à¸šà¸µà¸¢à¸™à¸«à¸¥à¸²à¸¢à¸§à¸´à¸Šà¸²", "1 à¸£à¸«à¸±à¸ª à¸¡à¸µà¸™à¸±à¸à¹€à¸£à¸µà¸¢à¸™ 1 à¸„à¸™"], answer: 1, difficulty: 'medium' }, // 1
  { q: "\"ER Diagram\" (à¹à¸œà¸™à¸ à¸²à¸ž ER) à¹ƒà¸Šà¹‰à¸­à¸˜à¸´à¸šà¸²à¸¢à¸­à¸°à¹„à¸£?", choices: ["à¹‚à¸Ÿà¸¥à¸§à¹Œà¸à¸²à¸£à¸—à¸³à¸‡à¸²à¸™à¹‚à¸›à¸£à¹à¸à¸£à¸¡", "à¹‚à¸„à¸£à¸‡à¸ªà¸£à¹‰à¸²à¸‡à¹à¸¥à¸°à¸„à¸§à¸²à¸¡à¸ªà¸±à¸¡à¸žà¸±à¸™à¸˜à¹Œà¸‚à¸­à¸‡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥", "à¸­à¸±à¸¥à¸à¸­à¸£à¸´à¸—à¸¶à¸¡", "à¸«à¸™à¹‰à¸²à¸ˆà¸­à¹‚à¸›à¸£à¹à¸à¸£à¸¡"], answer: 1, difficulty: 'medium' }, // 1
  { q: "à¸„à¸§à¸²à¸¡à¸ªà¸±à¸¡à¸žà¸±à¸™à¸˜à¹Œà¹à¸šà¸š \"Many-to-Many\" à¸¡à¸±à¸à¸•à¹‰à¸­à¸‡à¹ƒà¸Šà¹‰à¸­à¸°à¹„à¸£à¹ƒà¸™à¸à¸²à¸£à¸­à¸­à¸à¹à¸šà¸š?", choices: ["à¸•à¸²à¸£à¸²à¸‡à¸«à¸¥à¸±à¸ 2 à¸•à¸²à¸£à¸²à¸‡", "à¹„à¸¡à¹ˆà¸•à¹‰à¸­à¸‡à¹ƒà¸Šà¹‰à¸­à¸°à¹„à¸£", "à¸•à¸²à¸£à¸²à¸‡à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¹‚à¸¢à¸‡ (Junction Table)", "à¸„à¸µà¸¢à¹Œà¸™à¸­à¸à¹ƒà¸™à¸•à¸²à¸£à¸²à¸‡à¹€à¸”à¸µà¸¢à¸§"], answer: 2, difficulty: 'hard' }, // 1.5

  // Topic 4: SQL
  { q: "à¸„à¸³à¸ªà¸±à¹ˆà¸‡ `SELECT` à¹ƒà¸™ SQL à¹ƒà¸Šà¹‰à¸—à¸³à¸­à¸°à¹„à¸£?", choices: ["à¸¥à¸šà¸‚à¹‰à¸­à¸¡à¸¹à¸¥", "à¹€à¸žà¸´à¹ˆà¸¡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥", "à¹à¸à¹‰à¹„à¸‚à¸‚à¹‰à¸­à¸¡à¸¹à¸¥", "à¸”à¸¶à¸‡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥/à¸ªà¸­à¸šà¸–à¸²à¸¡"], answer: 3, difficulty: 'easy' }, // 0.5
  { q: "à¸„à¸³à¸ªà¸±à¹ˆà¸‡ `INSERT INTO`... à¹ƒà¸Šà¹‰à¸—à¸³à¸­à¸°à¹„à¸£?", choices: ["à¸¥à¸šà¸‚à¹‰à¸­à¸¡à¸¹à¸¥", "à¹€à¸žà¸´à¹ˆà¸¡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥", "à¹à¸à¹‰à¹„à¸‚à¸‚à¹‰à¸­à¸¡à¸¹à¸¥", "à¸”à¸¶à¸‡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥"], answer: 1, difficulty: 'easy' }, // 0.5
  { q: "à¸„à¸³à¸ªà¸±à¹ˆà¸‡ `UPDATE`... `SET`... à¹ƒà¸Šà¹‰à¸—à¸³à¸­à¸°à¹„à¸£?", choices: ["à¸¥à¸šà¸‚à¹‰à¸­à¸¡à¸¹à¸¥", "à¹€à¸žà¸´à¹ˆà¸¡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥", "à¹à¸à¹‰à¹„à¸‚à¸‚à¹‰à¸­à¸¡à¸¹à¸¥", "à¸”à¸¶à¸‡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥"], answer: 2, difficulty: 'easy' }, // 0.5
  { q: "`WHERE` clause à¹ƒà¸™ SQL à¹ƒà¸Šà¹‰à¸—à¸³à¸­à¸°à¹„à¸£?", choices: ["à¹€à¸£à¸µà¸¢à¸‡à¸¥à¸³à¸”à¸±à¸š", "à¸ˆà¸³à¸à¸±à¸”à¸ˆà¸³à¸™à¸§à¸™à¹à¸–à¸§", "à¸à¸³à¸«à¸™à¸”à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚", "à¸£à¸§à¸¡à¸•à¸²à¸£à¸²à¸‡"], answer: 2, difficulty: 'easy' }, // 0.5
  { q: "`JOIN` à¹ƒà¸™ SQL à¸¡à¸µà¹„à¸§à¹‰à¸—à¸³à¸­à¸°à¹„à¸£?", choices: ["à¹à¸¢à¸à¸•à¸²à¸£à¸²à¸‡", "à¸£à¸§à¸¡à¸•à¸²à¸£à¸²à¸‡à¸ˆà¸²à¸à¸„à¸§à¸²à¸¡à¸ªà¸±à¸¡à¸žà¸±à¸™à¸˜à¹Œ", "à¸¥à¸šà¸•à¸²à¸£à¸²à¸‡", "à¸ªà¸£à¹‰à¸²à¸‡à¸•à¸²à¸£à¸²à¸‡"], answer: 1, difficulty: 'medium' }, // 1
  { q: "`CREATE TABLE` à¹€à¸›à¹‡à¸™à¸„à¸³à¸ªà¸±à¹ˆà¸‡à¸›à¸£à¸°à¹€à¸ à¸—à¹ƒà¸”?", choices: ["DML (à¸ˆà¸±à¸”à¸à¸²à¸£à¸‚à¹‰à¸­à¸¡à¸¹à¸¥)", "DDL (à¸™à¸´à¸¢à¸²à¸¡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥)", "DCL (à¸„à¸§à¸šà¸„à¸¸à¸¡à¸ªà¸´à¸—à¸˜à¸´à¹Œ)", "TCL (à¸˜à¸¸à¸£à¸à¸£à¸£à¸¡)"], answer: 1, difficulty: 'medium' }, // 1
  { q: "`DELETE FROM students` (à¹‚à¸”à¸¢à¹„à¸¡à¹ˆà¸¡à¸µ WHERE) à¸ˆà¸°à¹€à¸à¸´à¸”à¸­à¸°à¹„à¸£à¸‚à¸¶à¹‰à¸™?", choices: ["à¸¥à¸šà¸•à¸²à¸£à¸²à¸‡ students", "à¸¥à¸šà¹à¸–à¸§à¹à¸£à¸", "à¸¥à¸šà¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”à¹ƒà¸™à¸•à¸²à¸£à¸²à¸‡ students", "Error"], answer: 2, difficulty: 'medium' }, // 1
  { q: "`GROUP BY` à¹ƒà¸™ SQL à¸¡à¸±à¸à¹ƒà¸Šà¹‰à¸£à¹ˆà¸§à¸¡à¸à¸±à¸šà¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¹ƒà¸”?", choices: ["`IF()`", "`NOW()`", "`CONNECT()`", "`COUNT()` à¸«à¸£à¸·à¸­ `SUM()`"], answer: 3, difficulty: 'hard' }, // 1.5

  // Topic 5: Performance
  { q: "\"Index\" (à¸”à¸±à¸Šà¸™à¸µ) à¹ƒà¸™à¸à¸²à¸™à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸Šà¹ˆà¸§à¸¢à¹€à¸£à¸·à¹ˆà¸­à¸‡à¸­à¸°à¹„à¸£?", choices: ["à¸„à¸§à¸²à¸¡à¸›à¸¥à¸­à¸”à¸ à¸±à¸¢", "à¸„à¸§à¸²à¸¡à¸–à¸¹à¸à¸•à¹‰à¸­à¸‡à¸‚à¸­à¸‡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥", "à¸„à¸§à¸²à¸¡à¹€à¸£à¹‡à¸§à¹ƒà¸™à¸à¸²à¸£à¸„à¹‰à¸™à¸«à¸²", "à¸à¸²à¸£à¸ªà¸³à¸£à¸­à¸‡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥"], answer: 2, difficulty: 'medium' }, // 1
  { q: "à¸à¸²à¸£à¸—à¸³ \"Query Optimization\" à¸„à¸·à¸­à¸­à¸°à¹„à¸£?", choices: ["à¸à¸²à¸£à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™à¸ªà¸µ Query", "à¸à¸²à¸£à¸›à¸£à¸±à¸šà¸›à¸£à¸¸à¸‡ Query à¹ƒà¸«à¹‰à¸—à¸³à¸‡à¸²à¸™à¹€à¸£à¹‡à¸§à¸‚à¸¶à¹‰à¸™", "à¸à¸²à¸£à¸¥à¸š Query", "à¸à¸²à¸£à¸•à¸±à¹‰à¸‡à¹€à¸§à¸¥à¸² Query"], answer: 1, difficulty: 'hard' }, // 1.5
  { q: "à¸–à¹‰à¸² Query à¸—à¸³à¸‡à¸²à¸™à¸Šà¹‰à¸²à¸¡à¸²à¸ à¸ªà¸´à¹ˆà¸‡à¹à¸£à¸à¸—à¸µà¹ˆà¸„à¸§à¸£à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸„à¸·à¸­à¸­à¸°à¹„à¸£?", choices: ["à¸à¸²à¸£à¸ªà¸°à¸à¸”à¸„à¸³", "à¸ªà¸µà¸‚à¸­à¸‡à¸•à¸²à¸£à¸²à¸‡", "à¸à¸²à¸£à¹ƒà¸Šà¹‰ Index", "à¸Šà¸·à¹ˆà¸­à¸œà¸¹à¹‰à¹ƒà¸Šà¹‰"], answer: 2, difficulty: 'medium' }, // 1
  { q: "\"Denormalization\" (à¸à¸²à¸£à¸¥à¸”à¸—à¸­à¸™à¸šà¸£à¸£à¸—à¸±à¸”à¸à¸²à¸™) à¸­à¸²à¸ˆà¸—à¸³à¹€à¸žà¸·à¹ˆà¸­à¸­à¸°à¹„à¸£?", choices: ["à¹€à¸žà¸´à¹ˆà¸¡à¸„à¸§à¸²à¸¡à¸›à¸¥à¸­à¸”à¸ à¸±à¸¢", "à¸¥à¸”à¸„à¸§à¸²à¸¡à¹€à¸£à¹‡à¸§à¹ƒà¸™à¸à¸²à¸£à¸­à¹ˆà¸²à¸™", "à¹€à¸žà¸´à¹ˆà¸¡à¸„à¸§à¸²à¸¡à¹€à¸£à¹‡à¸§à¹ƒà¸™à¸à¸²à¸£à¸­à¹ˆà¸²à¸™ (à¸¥à¸” Join)", "à¸¥à¸”à¸„à¸§à¸²à¸¡à¸‹à¹‰à¸³à¸‹à¹‰à¸­à¸™"], answer: 2, difficulty: 'hard' }, // 1.5

  // Topic 6: Security & Access
  { q: "à¸„à¸³à¸ªà¸±à¹ˆà¸‡ `GRANT` à¹ƒà¸™ SQL à¹ƒà¸Šà¹‰à¸—à¸³à¸­à¸°à¹„à¸£?", choices: ["à¹ƒà¸«à¹‰à¸ªà¸´à¸—à¸˜à¸´à¹Œ", "à¸¢à¸¶à¸”à¸ªà¸´à¸—à¸˜à¸´à¹Œ", "à¸ªà¸£à¹‰à¸²à¸‡à¸œà¸¹à¹‰à¹ƒà¸Šà¹‰", "à¸¥à¸šà¸œà¸¹à¹‰à¹ƒà¸Šà¹‰"], answer: 0, difficulty: 'medium' }, // 1
  { q: "à¸„à¸³à¸ªà¸±à¹ˆà¸‡ `REVOKE` à¹ƒà¸™ SQL à¹ƒà¸Šà¹‰à¸—à¸³à¸­à¸°à¹„à¸£?", choices: ["à¹ƒà¸«à¹‰à¸ªà¸´à¸—à¸˜à¸´à¹Œ", "à¸¢à¸¶à¸”à¸ªà¸´à¸—à¸˜à¸´à¹Œ", "à¸ªà¸£à¹‰à¸²à¸‡à¸œà¸¹à¹‰à¹ƒà¸Šà¹‰", "à¸¥à¸šà¸œà¸¹à¹‰à¹ƒà¸Šà¹‰"], answer: 1, difficulty: 'medium' }, // 1
  { q: "\"SQL Injection\" à¸„à¸·à¸­à¸­à¸°à¹„à¸£?", choices: ["à¸à¸²à¸£à¹€à¸žà¸´à¹ˆà¸¡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥", "à¸à¸²à¸£à¸­à¸±à¸›à¹€à¸”à¸•à¸‚à¹‰à¸­à¸¡à¸¹à¸¥", "à¸à¸²à¸£à¹‚à¸ˆà¸¡à¸•à¸µà¸œà¹ˆà¸²à¸™à¸Šà¹ˆà¸­à¸‡à¹‚à¸«à¸§à¹ˆ SQL", "à¸à¸²à¸£à¸ªà¸³à¸£à¸­à¸‡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥"], answer: 2, difficulty: 'medium' }, // 1
  { q: "\"Role-Based Access Control\" (RBAC) à¸„à¸·à¸­à¸­à¸°à¹„à¸£?", choices: ["à¸à¸²à¸£à¸„à¸§à¸šà¸„à¸¸à¸¡à¹‚à¸”à¸¢à¹ƒà¸Šà¹‰à¸Šà¸·à¹ˆà¸­", "à¸à¸²à¸£à¸à¸³à¸«à¸™à¸”à¸ªà¸´à¸—à¸˜à¸´à¹Œà¸•à¸²à¸¡à¸šà¸—à¸šà¸²à¸—/à¸«à¸™à¹‰à¸²à¸—à¸µà¹ˆ", "à¸à¸²à¸£à¸ªà¸³à¸£à¸­à¸‡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥", "à¸à¸²à¸£à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­à¹à¸­à¸›"], answer: 1, difficulty: 'hard' }, // 1.5

  // Topic 7: Backup & Restore
  { q: "à¸à¸²à¸£ \"Backup\" (à¸ªà¸³à¸£à¸­à¸‡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥) à¸à¸²à¸™à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸„à¸·à¸­à¸­à¸°à¹„à¸£?", choices: ["à¸à¸²à¸£à¸¥à¸šà¸‚à¹‰à¸­à¸¡à¸¹à¸¥", "à¸à¸²à¸£à¸à¸¹à¹‰à¸„à¸·à¸™", "à¸à¸²à¸£à¸„à¸±à¸”à¸¥à¸­à¸/à¸ˆà¸±à¸”à¹€à¸à¹‡à¸šà¸‚à¹‰à¸­à¸¡à¸¹à¸¥", "à¸à¸²à¸£à¹€à¸žà¸´à¹ˆà¸¡à¸„à¸§à¸²à¸¡à¹€à¸£à¹‡à¸§"], answer: 2, difficulty: 'easy' }, // 0.5
  { q: "\"Full Backup\" à¸•à¹ˆà¸²à¸‡à¸ˆà¸²à¸ \"Incremental Backup\" à¸­à¸¢à¹ˆà¸²à¸‡à¹„à¸£?", choices: ["Full à¹€à¸£à¹‡à¸§à¸à¸§à¹ˆà¸²", "Full à¹€à¸à¹‡à¸šà¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”", "Full à¹ƒà¸Šà¹‰à¸—à¸µà¹ˆà¸™à¹‰à¸­à¸¢à¸à¸§à¹ˆà¸²", "Full à¸à¸¹à¹‰à¸„à¸·à¸™à¹„à¸¡à¹ˆà¹„à¸”à¹‰"], answer: 1, difficulty: 'medium' }, // 1
  { q: "\"Transaction Log\" à¸¡à¸µà¸„à¸§à¸²à¸¡à¸ªà¸³à¸„à¸±à¸à¸­à¸¢à¹ˆà¸²à¸‡à¹„à¸£?", choices: ["à¹ƒà¸Šà¹‰à¹€à¸à¹‡à¸šà¸£à¸«à¸±à¸ªà¸œà¹ˆà¸²à¸™", "à¹ƒà¸Šà¹‰à¸ªà¸³à¸«à¸£à¸±à¸šà¸à¸¹à¹‰à¸„à¸·à¸™à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸£à¸°à¸«à¸§à¹ˆà¸²à¸‡ Backup", "à¹ƒà¸Šà¹‰à¹€à¸à¹‡à¸šà¸œà¸¥ Query", "à¹ƒà¸Šà¹‰à¹€à¸£à¹ˆà¸‡à¸„à¸§à¸²à¸¡à¹€à¸£à¹‡à¸§"], answer: 1, difficulty: 'medium' }, // 1

  // Topic 8 & 10: Connecting to Apps (Colab/Python)
  { q: "à¹ƒà¸™ Colab, à¹€à¸£à¸²à¹ƒà¸Šà¹‰à¹„à¸¥à¸šà¸£à¸²à¸£à¸µà¹ƒà¸”à¹€à¸žà¸·à¹ˆà¸­à¸ˆà¸±à¸”à¸à¸²à¸£à¸à¸²à¸™à¸‚à¹‰à¸­à¸¡à¸¹à¸¥ SQLite?", choices: ["`numpy`", "`matplotlib`", "`sqlite3`", "`tensorflow`"], answer: 2, difficulty: 'easy' }, // 0.5
  { q: "`import sqlite3` à¹ƒà¸™ Python (Colab) à¹ƒà¸Šà¹‰à¸—à¸³à¸­à¸°à¹„à¸£?", choices: ["à¸™à¸³à¹€à¸‚à¹‰à¸²à¹„à¸¥à¸šà¸£à¸²à¸£à¸µ SQLite", "à¸ªà¸£à¹‰à¸²à¸‡à¸à¸²à¸™à¸‚à¹‰à¸­à¸¡à¸¹à¸¥", "à¸¥à¸šà¸à¸²à¸™à¸‚à¹‰à¸­à¸¡à¸¹à¸¥", "à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­à¸­à¸´à¸™à¹€à¸—à¸­à¸£à¹Œà¹€à¸™à¹‡à¸•"], answer: 0, difficulty: 'medium' }, // 1
  { q: "`conn = sqlite3.connect('test.db')` à¹ƒà¸™ Colab à¸—à¸³à¸­à¸°à¹„à¸£?", choices: ["à¸¥à¸šà¹„à¸Ÿà¸¥à¹Œ test.db", "à¸ªà¸£à¹‰à¸²à¸‡/à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­à¸à¸²à¸™à¸‚à¹‰à¸­à¸¡à¸¹à¸¥ test.db", "à¹à¸ªà¸”à¸‡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥", "à¸£à¸±à¸™ SQL"], answer: 1, difficulty: 'medium' }, // 1
  { q: "à¹€à¸£à¸²à¸ªà¸²à¸¡à¸²à¸£à¸–à¸•à¸´à¸”à¸•à¸±à¹‰à¸‡à¹„à¸”à¸£à¹€à¸§à¸­à¸£à¹Œà¸à¸²à¸™à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸­à¸·à¹ˆà¸™ (à¹€à¸Šà¹ˆà¸™ MySQL) à¹ƒà¸™ Colab à¹„à¸”à¹‰à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ?", choices: ["à¹„à¸¡à¹ˆà¹„à¸”à¹‰", "à¹„à¸”à¹‰ (à¹€à¸Šà¹ˆà¸™ `!pip install ...`)", "à¹„à¸”à¹‰ à¹à¸•à¹ˆà¸•à¹‰à¸­à¸‡à¸ˆà¹ˆà¸²à¸¢à¹€à¸‡à¸´à¸™", "à¹„à¸”à¹‰ à¹à¸„à¹ˆ SQLite à¹€à¸—à¹ˆà¸²à¸™à¸±à¹‰à¸™"], answer: 1, difficulty: 'medium' }, // 1
  { q: "`cursor.execute(\"SELECT...\")` à¹ƒà¸™ Python (Colab) à¹ƒà¸Šà¹‰à¸—à¸³à¸­à¸°à¹„à¸£?", choices: ["à¸›à¸´à¸”à¸à¸²à¸£à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­", "à¸£à¸±à¸™à¸„à¸³à¸ªà¸±à¹ˆà¸‡ SQL", "à¸”à¸¶à¸‡à¸œà¸¥à¸¥à¸±à¸žà¸˜à¹Œ (Fetch)", "à¸ªà¸£à¹‰à¸²à¸‡à¸•à¸²à¸£à¸²à¸‡à¹€à¸—à¹ˆà¸²à¸™à¸±à¹‰à¸™"], answer: 1, difficulty: 'hard' }, // 1.5
  { q: "`pd.read_sql_query(sql, conn)` à¹ƒà¸™ Colab (Pandas) à¹ƒà¸Šà¹‰à¸—à¸³à¸­à¸°à¹„à¸£?", choices: ["à¸£à¸±à¸™ SQL à¹à¸¥à¹‰à¸§à¹€à¸à¹‡à¸šà¸œà¸¥à¸¥à¸±à¸žà¸˜à¹Œà¹ƒà¸™ DataFrame", "à¸ªà¸£à¹‰à¸²à¸‡à¸„à¸³à¸ªà¸±à¹ˆà¸‡ SQL", "à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­à¸à¸²à¸™à¸‚à¹‰à¸­à¸¡à¸¹à¸¥", "à¹€à¸‚à¸µà¸¢à¸™ SQL à¸¥à¸‡à¹„à¸Ÿà¸¥à¹Œ"], answer: 0, difficulty: 'hard' }, // 1.5
  { q: "`df.to_sql('my_table', conn)` à¹ƒà¸™ Colab (Pandas) à¹ƒà¸Šà¹‰à¸—à¸³à¸­à¸°à¹„à¸£?", choices: ["à¸­à¹ˆà¸²à¸™à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸ˆà¸²à¸à¸•à¸²à¸£à¸²à¸‡", "à¸¥à¸šà¸•à¸²à¸£à¸²à¸‡", "à¹€à¸‚à¸µà¸¢à¸™à¸‚à¹‰à¸­à¸¡à¸¹à¸¥ DataFrame à¸¥à¸‡à¸•à¸²à¸£à¸²à¸‡", "à¹à¸ªà¸”à¸‡à¹‚à¸„à¸£à¸‡à¸ªà¸£à¹‰à¸²à¸‡à¸•à¸²à¸£à¸²à¸‡"], answer: 2, difficulty: 'hard' }, // 1.5

  // Topic 9: Troubleshooting
  { q: "\"Deadlock\" (à¸à¸²à¸£à¸•à¸´à¸”à¸•à¸²à¸¢) à¹ƒà¸™à¸à¸²à¸™à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸„à¸·à¸­à¸­à¸°à¹„à¸£?", choices: ["à¸à¸²à¸™à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸«à¸¢à¸¸à¸”à¸—à¸³à¸‡à¸²à¸™", "à¸œà¸¹à¹‰à¹ƒà¸Šà¹‰ 2 à¸„à¸™à¸£à¸­à¸—à¸£à¸±à¸žà¸¢à¸²à¸à¸£à¸à¸±à¸™à¹„à¸›à¸¡à¸²", "à¹„à¸Ÿà¸”à¸±à¸š", "à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸ªà¸¹à¸à¸«à¸²à¸¢"], answer: 1, difficulty: 'medium' }, // 1
  { q: "\"Data inconsistency\" (à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¹„à¸¡à¹ˆà¸ªà¸­à¸”à¸„à¸¥à¹‰à¸­à¸‡à¸à¸±à¸™) à¸«à¸¡à¸²à¸¢à¸–à¸¶à¸‡à¸­à¸°à¹„à¸£?", choices: ["à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¹€à¸£à¹‡à¸§à¹€à¸à¸´à¸™à¹„à¸›", "à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸—à¸µà¹ˆà¸„à¸§à¸£à¹€à¸«à¸¡à¸·à¸­à¸™à¸à¸±à¸™à¹à¸•à¹ˆà¹„à¸¡à¹ˆà¹€à¸«à¸¡à¸·à¸­à¸™à¸à¸±à¸™", "à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸™à¹‰à¸­à¸¢à¹€à¸à¸´à¸™à¹„à¸›", "à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸–à¸¹à¸à¹€à¸‚à¹‰à¸²à¸£à¸«à¸±à¸ª"], answer: 1, difficulty: 'hard' }, // 1.5
];
// --- END OF NEW QUESTIONS ---

// --- ENHANCEMENT: Added descriptions for tooltips ---
const SPECIAL_SKILLS = [
    { id: 'attack_boost_10', name: 'Attack+ 10%', cost: 2, desc: 'Increases your next attack damage by 10%.' },
    { id: 'heal_40', name: 'Heal 40 HP', cost: 3, desc: 'Instantly restores 40 HP.' },
    { id: 'block_1', name: 'Block Attack', cost: 4, desc: 'Completely blocks the opponent\'s next attack.' },
    { id: 'weaken_30', name: 'Weaken Opp.', cost: 2.5, desc: 'Reduces opponent\'s next attack damage by 30%.' },
    { id: 'combo_guard', name: 'Combo Guard', cost: 2, desc: 'Saves your combo if you answer incorrectly. One use.' }
];

class MainScene extends Phaser.Scene {
  constructor() {
    super('main');
  }

  create() {
    this.cameras.main.setBackgroundColor('#87ceeb');
    
    // --- NEW: Name Input State ---
    this.gameState = 'NAME_INPUT';
    this.player1Name = '';
    this.player2Name = '';
    this.currentNameInput = 1;
    this.inputtingName = '';
    
    // --- GAME STATE ---
    this.skillSelectionCount = 0;
    this.selectingPlayer = 1;
    this.player1HP = 100;
    this.player2HP = 100;
    this.player1Score = 0;
    this.player2Score = 0;
    this.player1SkillPoints = 0;
    this.player2SkillPoints = 0;
    this.player1Streak = 0;
    this.player2Streak = 0;
    this.playerBuffs = { 1: null, 2: null };
    this.nextBuffTargets = { 1: 3, 2: 3 };
    this.playerSpecials = {
        1: [{ skill: null, skillName: '', used: false }, { skill: null, skillName: '', used: false }],
        2: [{ skill: null, skillName: '', used: false }, { skill: null, skillName: '', used: false }]
    };
    
    // --- STATS TRACKING ---
    this.roundStats = { 1: this.resetStatsObject(), 2: this.resetStatsObject() };
    this.matchStats = { 1: this.resetStatsObject(), 2: this.resetStatsObject() };

    this.currentPlayer = 1;
    this.questionIndex = 0;
    this.gameOver = false;
    this.roundOver = false;
    this.shuffledQuestions = this.shuffleArray([...QUESTIONS]);

    // this.showSkillSelectionScreen(); // Will be called after name input
    this.showNameInputScreen();
  }
  
  resetStatsObject() {
    return {
        questionsAnswered: 0,
        correctAnswers: 0,
        pointsEarned: 0,
        maxCombo: 0,
        maxDamage: 0,
        minDamage: Infinity
    };
  }

  // --- NEW: Name Input Functions ---
  showNameInputScreen() {
    this.nameInputTitle = this.add.text(GAME_WIDTH / 2, 150, "à¸œà¸¹à¹‰à¹€à¸¥à¹ˆà¸™ 1: à¹ƒà¸ªà¹ˆà¸Šà¸·à¹ˆà¸­à¸‚à¸­à¸‡à¸„à¸¸à¸“", { fontSize: '48px', fontFamily: '"Poppins", sans-serif', color: '#FFFFFF', stroke: '#000000', strokeThickness: 4 }).setOrigin(0.5);
    
    this.nameInputBG = this.add.graphics().fillStyle(0x000, 0.5).fillRoundedRect(GAME_WIDTH/2 - 200, 250, 400, 80, 10);
    this.nameInputText = this.add.text(GAME_WIDTH / 2, 290, "_", { fontSize: '40px', fontFamily: '"Poppins", sans-serif', color: '#FFFFFF', fixedWidth: 380, align: 'center' }).setOrigin(0.5);
    
    this.nameInputInstructions = this.add.text(GAME_WIDTH / 2, 380, "à¸žà¸´à¸¡à¸žà¹Œà¸Šà¸·à¹ˆà¸­ (à¹„à¸—à¸¢/à¸­à¸±à¸‡à¸à¸¤à¸©) à¹à¸¥à¸°à¸à¸” Enter\n(à¸ªà¸¹à¸‡à¸ªà¸¸à¸” 12 à¸•à¸±à¸§à¸­à¸±à¸à¸©à¸£)", { fontSize: '20px', fontFamily: '"Poppins", sans-serif', color: '#fff', align: 'center' }).setOrigin(0.5);

    // Start keyboard listener
    this.keyListener = this.input.keyboard.on('keydown', this.handleKeyInput, this);
  }

  handleKeyInput(event) {
    if (this.gameState !== 'NAME_INPUT') return;

    const key = event.key;

    if (key === 'Backspace') { // Backspace
        this.inputtingName = this.inputtingName.slice(0, -1);
    } else if (key === 'Enter' && this.inputtingName.length > 0) { // Enter
        if (this.currentNameInput === 1) {
            this.player1Name = this.inputtingName;
            this.currentNameInput = 2;
            this.inputtingName = '';
            this.nameInputTitle.setText("à¸œà¸¹à¹‰à¹€à¸¥à¹ˆà¸™ 2: à¹ƒà¸ªà¹ˆà¸Šà¸·à¹ˆà¸­à¸‚à¸­à¸‡à¸„à¸¸à¸“");
        } else {
            this.player2Name = this.inputtingName;
            // Stop listener and transition
            this.input.keyboard.off('keydown', this.handleKeyInput, this);
            this.transitionToSkillSelect();
        }
    } else if (this.inputtingName.length < 12 && /^[a-zA-Z\s\u0E00-\u0E7F]$/.test(key)) {
        // Only allow letters (a-z, A-Z), space, and Thai characters (U+0E00 to U+0E7F)
        this.inputtingName += key;
    }
    
    // Update display text
    this.nameInputText.setText(this.inputtingName + (this.inputtingName.length < 12 ? "_" : ""));
  }
  
  transitionToSkillSelect() {
    this.gameState = 'SKILL_SELECT';
    
    // Clean up name input UI
    this.nameInputTitle.destroy();
    this.nameInputBG.destroy();
    this.nameInputText.destroy();
    this.nameInputInstructions.destroy();
    
    // Start next screen
    this.showSkillSelectionScreen();
  }
  // --- End of Name Input Functions ---


  showSkillSelectionScreen() {
    this.selectionTitle = this.add.text(GAME_WIDTH / 2, 100, `${this.player1Name}: Choose Skill (1/2)`, { fontSize: '48px', fontFamily: '"Poppins", sans-serif', color: '#FFFFFF', stroke: '#000000', strokeThickness: 4 }).setOrigin(0.5);
    
    this.selectableSkillIcons = [];
    SPECIAL_SKILLS.slice(0, 4).forEach((skill, index) => { // Only show first 4 skills for selection
        const x = (GAME_WIDTH / 2) - 255 + (index * 170);
        const y = 280;
        const icon = this.createSkillSelectionIcon(x, y, skill);
        icon.setData('skill', skill);
        this.selectableSkillIcons.push(icon);
    });
  }

  createSkillSelectionIcon(x, y, skill) {
    const container = this.add.container(x, y);
    const background = this.add.graphics();
    background.fillStyle(0x333333, 1);
    background.fillRoundedRect(-70, -50, 140, 130, 15);
    background.lineStyle(3, 0xffffff, 1);
    background.strokeRoundedRect(-70, -50, 140, 130, 15);

    const iconContainer = this.createSpecialSkillIcon(0, -10, { skill: skill.id });
    
    const skillText = this.add.text(0, 50, skill.name, { fontSize: '20px', fontFamily: '"Poppins", sans-serif', color: '#fff', align: 'center', wordWrap: { width: 120 } }).setOrigin(0.5);

    container.add([background, iconContainer, skillText]);
    container.setSize(140, 130);
    container.setInteractive({ useHandCursor: true })
        .on('pointerdown', () => {
            if(container.input.enabled) {
                this.tweens.add({ targets: container, scale: 0.9, duration: 100, ease: 'Power1', yoyo: true, onComplete: () => this.onSkillSelected(skill, container) });
            }
        })
        .on('pointerover', () => { if(container.input.enabled) this.tweens.add({ targets: container, scale: 1.05, duration: 200, ease: 'Power2' }); })
        .on('pointerout', () => { if(container.input.enabled) this.tweens.add({ targets: container, scale: 1, duration: 200, ease: 'Power2' }); });

    return container;
  }

  onSkillSelected(skill, selectedIcon) {
    const skillIndex = this.skillSelectionCount % 2;
    this.playerSpecials[this.selectingPlayer][skillIndex] = { skill: skill.id, skillName: skill.name, used: false };
    
    selectedIcon.disableInteractive().setAlpha(0.5);

    this.skillSelectionCount++;

    if (this.skillSelectionCount === 1) { 
        this.selectionTitle.setText(`${this.player1Name}: Choose Skill (2/2)`);
    } else if (this.skillSelectionCount === 2) { 
        this.time.delayedCall(500, () => {
            this.selectingPlayer = 2;
            this.selectionTitle.setText(`${this.player2Name}: Choose Skill (1/2)`);
            this.selectableSkillIcons.forEach(icon => {
                icon.setInteractive({ useHandCursor: true }).setAlpha(1);
            });
        }, [], this);
    } else if (this.skillSelectionCount === 3) { 
        this.selectionTitle.setText(`${this.player2Name}: Choose Skill (2/2)`);
    } else if (this.skillSelectionCount === 4) { 
        this.time.delayedCall(500, this.transitionToGame, [], this);
    }
  }

  transitionToGame() {
    this.selectionTitle.destroy();
    this.selectableSkillIcons.forEach(icon => icon.destroy());
    this.gameState = 'PLAYING';
    this.currentPlayer = 1;
    this.setupMainGameUI();
    this.createSkillShop();
    this.createTooltip();
    this.updateTurnUI(this.currentPlayer);
    this.nextQuestion();
  }

  setupMainGameUI() {
    this.add.text(GAME_WIDTH / 2, 40, "Code Quiz Battle!", { fontSize: '56px', fontFamily: '"Poppins", sans-serif', color: '#FFFFFF', stroke: '#000000', strokeThickness: 5 }).setOrigin(0.5);

    // --- PLAYER 1 INFO ---
    const p1_ui_x = 250;
    this.player1Sprite = this.createRobloxAvatar(p1_ui_x, 320, 1);
    this.player1HPBar = this.createHpBar(p1_ui_x, 100, this.player1Name);
    this.player1ScoreText = this.add.text(p1_ui_x, 135, "Wins: 0", { fontSize: '20px', fontFamily: '"Poppins", sans-serif', color: '#fff', stroke: '#000', strokeThickness: 2 }).setOrigin(0.5);
    this.player1PointsText = this.add.text(p1_ui_x, 160, "Points: 0", { fontSize: '20px', fontFamily: '"Poppins", sans-serif', color: '#ffd700', stroke: '#000', strokeThickness: 2 }).setOrigin(0.5);
    this.player1StreakText = this.add.text(p1_ui_x, 185, "COMBO!", { fontSize: '20px', fontFamily: '"Poppins", sans-serif', color: '#ff9800', stroke: '#000', strokeThickness: 3 }).setOrigin(0.5).setAlpha(0);
    this.player1BuffText = this.add.text(p1_ui_x, 210, "", { fontSize: '18px', fontFamily: '"Poppins", sans-serif', color: '#ffeb3b', stroke: '#000', strokeThickness: 2 }).setOrigin(0.5).setAlpha(0);
    this.player1SkillButtons = [
        this.createSpecialSkillIcon(p1_ui_x - 100, 240, this.playerSpecials[1][0], true, 1, 0),
        this.createSpecialSkillIcon(p1_ui_x - 100, 310, this.playerSpecials[1][1], true, 1, 1)
    ];
    this.player1ShopButton = this.createShopButton(p1_ui_x - 100, 380, 1);
    this.updateHpBar(this.player1HPBar, this.player1HP, 100);

    // --- PLAYER 2 INFO ---
    const p2_ui_x = GAME_WIDTH - 250;
    this.player2Sprite = this.createRobloxAvatar(p2_ui_x, 320, 2);
    this.player2HPBar = this.createHpBar(p2_ui_x, 100, this.player2Name);
    this.player2ScoreText = this.add.text(p2_ui_x, 135, "Wins: 0", { fontSize: '20px', fontFamily: '"Poppins", sans-serif', color: '#fff', stroke: '#000', strokeThickness: 2 }).setOrigin(0.5);
    this.player2PointsText = this.add.text(p2_ui_x, 160, "Points: 0", { fontSize: '20px', fontFamily: '"Poppins", sans-serif', color: '#ffd700', stroke: '#000', strokeThickness: 2 }).setOrigin(0.5);
    this.player2StreakText = this.add.text(p2_ui_x, 185, "COMBO!", { fontSize: '20px', fontFamily: '"Poppins", sans-serif', color: '#ff9800', stroke: '#000', strokeThickness: 3 }).setOrigin(0.5).setAlpha(0);
    this.player2BuffText = this.add.text(p2_ui_x, 210, "", { fontSize: '18px', fontFamily: '"Poppins", sans-serif', color: '#ffeb3b', stroke: '#000', strokeThickness: 2 }).setOrigin(0.5).setAlpha(0);
    this.player2SkillButtons = [
        this.createSpecialSkillIcon(p2_ui_x + 100, 240, this.playerSpecials[2][0], true, 2, 0),
        this.createSpecialSkillIcon(p2_ui_x + 100, 310, this.playerSpecials[2][1], true, 2, 1)
    ];
    this.player2ShopButton = this.createShopButton(p2_ui_x + 100, 380, 2);
    this.updateHpBar(this.player2HPBar, this.player2HP, 100);
    
    // --- QUESTION AREA ---
    this.questionBg = this.add.graphics();
    this.questionBg.fillStyle(0xffffff, 1).fillRoundedRect(20, 410, GAME_WIDTH - 40, 200, 16);
    this.questionBg.lineStyle(4, 0x000000, 1).strokeRoundedRect(20, 410, GAME_WIDTH - 40, 200, 16);
    
    this.questionText = this.add.text(GAME_WIDTH/2, 440, "", { fontSize: '22px', wordWrap: { width: GAME_WIDTH - 80 }, align: 'center', color: '#000000', fontFamily: '"Poppins", sans-serif', }).setOrigin(0.5);
    
    this.choiceTexts = [];
    for (let i = 0; i < 4; i++) {
        let t = this.add.text(0, 0, "", { fontSize: '20px', backgroundColor: '#4a90e2', padding: { x: 10, y: 5 }, align: 'center', fixedWidth: 450, color: '#ffffff', fontFamily: '"Poppins", sans-serif', })
            .setInteractive({ useHandCursor: true })
            .on('pointerdown', () => { if (t.input.enabled) this.tweens.add({ targets: t, scale: 0.95, yoyo: true, duration: 100, ease: 'Power1', onComplete: () => this.onChoice(i) }); })
            .on('pointerover', () => { if(t.input.enabled) t.setStyle({ backgroundColor: '#357abd' })})
            .on('pointerout', () => { if(t.input.enabled) t.setStyle({ backgroundColor: '#4a90e2' })});
        this.choiceTexts.push(t);
    }
    Phaser.Actions.GridAlign(this.choiceTexts, { width: 2, height: 2, cellWidth: 480, cellHeight: 55, x: 32, y: 490 });

    this.statusText = this.add.text(GAME_WIDTH/2, 380, "", { fontSize: '32px', fontFamily: '"Poppins", sans-serif', color: '#ffea00', stroke: '#000', strokeThickness: 3}).setOrigin(0.5);
    this.buffText = this.add.text(GAME_WIDTH/2, 340, "", { fontSize: '36px', fontFamily: '"Poppins", sans-serif', color: '#4caf50', stroke: '#fff', strokeThickness: 4 }).setOrigin(0.5).setAlpha(0);
    
    this.attackButton = this.createActionButton(GAME_WIDTH/2 - 120, 520, 'Attack', '#ff4d4d', this.handleAttack);
    this.healButton = this.createActionButton(GAME_WIDTH/2 + 120, 520, 'Heal', '#4CAF50', this.handleHeal);
    this.hideActionButtons();
  }

  createSpecialSkillIcon(x, y, playerSpecial, isButton = false, playerNum = 0, skillIndex = 0) {
    const container = this.add.container(x, y);
    const background = this.add.graphics();
    background.fillStyle(0x9c27b0, 1).fillCircle(0, 0, 30).lineStyle(2, 0xffffff, 1).strokeCircle(0, 0, 30);
    const icon = this.add.graphics();
    const skillId = playerSpecial.skill;
    switch (skillId) {
        case 'attack_boost_10': icon.fillStyle(0xffa500).fillTriangle(-5, 15, 5, 15, 0, 5); icon.fillStyle(0xcccccc).fillRect(-3, -15, 6, 20); icon.fillStyle(0x8B4513).fillRect(-8, 5, 16, 4); break;
        case 'heal_40': icon.fillStyle(0x00ff00).fillRect(-12, -3, 24, 6); icon.fillRect(-3, -12, 6, 24); break;
        case 'block_1': icon.fillStyle(0x4169e1); icon.beginPath(); icon.moveTo(-15, -15); icon.lineTo(15, -15); icon.lineTo(15, 5); icon.lineTo(0, 15); icon.lineTo(-15, 5); icon.closePath(); icon.fillPath(); break;
        case 'weaken_30': icon.fillStyle(0x808080); icon.beginPath(); icon.moveTo(-15, -15); icon.lineTo(15, -15); icon.lineTo(15, 5); icon.lineTo(0, 15); icon.lineTo(-15, 5); icon.closePath(); icon.fillPath(); icon.lineStyle(2, 0x000000); icon.beginPath(); icon.moveTo(-5, -10); icon.lineTo(0, 0); icon.lineTo(5, 2); icon.lineTo(2, 10); icon.strokePath(); break;
        case 'combo_guard': icon.fillStyle(0xffd700).fillCircle(0, 5, 12); icon.fillStyle(0xff4500).fillTriangle(-8, 5, 8, 5, 0, -10); icon.lineStyle(1, 0xffffff); icon.strokeCircle(0, 5, 12); break;
    }
    container.add([background, icon]);

    // --- ENHANCEMENT: Added tooltips to skill buttons ---
    const skillData = SPECIAL_SKILLS.find(s => s.id === skillId);
    if (isButton) {
        container.setSize(60, 60).setInteractive({ useHandCursor: true })
            .on('pointerdown', () => { if (container.input.enabled) this.tweens.add({ targets: container, scale: 0.9, yoyo: true, duration: 100, onComplete: () => this.useSpecialSkill(playerNum, skillIndex) }); })
            .on('pointerover', () => { 
                if (container.input.enabled && skillData) {
                    this.tweens.add({ targets: container, scale: 1.1, duration: 200, ease: 'Power2' });
                    this.showTooltip(x, y - 60, `${skillData.name}\n\n${skillData.desc}`);
                }
            })
            .on('pointerout', () => { 
                if (container.input.enabled) {
                    this.tweens.add({ targets: container, scale: 1, duration: 200, ease: 'Power2' });
                    this.hideTooltip();
                }
            });
    }
    return container;
  }

  useSpecialSkill(playerNum, skillIndex) {
    if (this.currentPlayer !== playerNum || this.playerSpecials[playerNum][skillIndex].used || this.roundOver || this.gameOver || this.attackButton.visible) return;
    const skill = this.playerSpecials[playerNum][skillIndex].skill;
    const opponentNum = playerNum === 1 ? 2 : 1;
    this.playerSpecials[playerNum][skillIndex].used = true;
    const skillButton = (playerNum === 1) ? this.player1SkillButtons[skillIndex] : this.player2SkillButtons[skillIndex];
    skillButton.setAlpha(0.4).disableInteractive();
    this.hideTooltip(); // Hide tooltip when used
    switch(skill) {
        case 'attack_boost_10': this.playerBuffs[playerNum] = { type: 'special_attack_boost' }; this.showBuffMessage('SPECIAL: ATTACK BOOST!'); if (playerNum === 1) this.player1BuffText.setText('ATK UP 10% ðŸ”¥').setAlpha(1); else this.player2BuffText.setText('ATK UP 10% ðŸ”¥').setAlpha(1); break;
        case 'heal_40': const healAmount = 40; if (playerNum === 1) { this.player1HP = Math.min(100, this.player1HP + healAmount); this.updateHpBar(this.player1HPBar, this.player1HP, 100); this.showDamageText(this.player1Sprite.x, this.player1Sprite.y, `+${healAmount}`, '#00ff00'); } else { this.player2HP = Math.min(100, this.player2HP + healAmount); this.updateHpBar(this.player2HPBar, this.player2HP, 100); this.showDamageText(this.player2Sprite.x, this.player2Sprite.y, `+${healAmount}`, '#00ff00'); } this.showBuffMessage('SPECIAL: RECOVERED 40 HP!'); break;
        case 'block_1': this.playerBuffs[playerNum] = { type: 'block' }; this.showBuffMessage('SPECIAL: BLOCK ACTIVATED!'); if (playerNum === 1) this.player1BuffText.setText('BLOCK ACTIVE ðŸ›¡ï¸').setAlpha(1); else this.player2BuffText.setText('BLOCK ACTIVE ðŸ›¡ï¸').setAlpha(1); break;
        case 'weaken_30': this.playerBuffs[opponentNum] = { type: 'special_weaken' }; this.showBuffMessage("SPECIAL: OPPONENT WEAKENED!"); if (opponentNum === 1) this.player1BuffText.setText('ATK DOWN 30% ðŸ›¡ï¸').setAlpha(1); else this.player2BuffText.setText('ATK DOWN 30% ðŸ›¡ï¸').setAlpha(1); break;
    }
  }

  createShopButton(x, y, playerNum) {
    const container = this.add.container(x, y);
    const background = this.add.graphics().fillStyle(0xfdd835).fillCircle(0, 0, 30).lineStyle(2, 0xffffff).strokeCircle(0, 0, 30);
    const icon = this.add.text(0, 0, '$', { fontSize: '32px', fontFamily: '"Poppins", sans-serif', color: '#000' }).setOrigin(0.5);
    container.add([background, icon]);
    container.setSize(60, 60).setInteractive({ useHandCursor: true })
        .on('pointerdown', () => { if (container.input.enabled) this.tweens.add({ targets: container, scale: 0.9, yoyo: true, duration: 100, onComplete: () => this.showSkillShop(playerNum) }); })
        .on('pointerover', () => { if (container.input.enabled) this.tweens.add({ targets: container, scale: 1.1, duration: 200, ease: 'Power2' }); })
        .on('pointerout', () => { if (container.input.enabled) this.tweens.add({ targets: container, scale: 1, duration: 200, ease: 'Power2' }); });
    return container;
  }

  createSkillShop() {
    this.skillShopContainer = this.add.container(GAME_WIDTH / 2, GAME_HEIGHT / 2).setDepth(10).setAlpha(0);
    const bg = this.add.graphics().fillStyle(0x000000, 0.8).fillRect(-GAME_WIDTH / 2, -GAME_HEIGHT / 2, GAME_WIDTH, GAME_HEIGHT);
    const panel = this.add.graphics().fillStyle(0x333, 1).fillRoundedRect(-300, -220, 600, 440, 15).lineStyle(3, 0xffffff).strokeRoundedRect(-300, -220, 600, 440, 15);
    const title = this.add.text(0, -190, 'Skill Shop', { fontSize: '40px', fontFamily: '"Poppins", sans-serif', color: '#fff', stroke: '#000', strokeThickness: 3 }).setOrigin(0.5);
    const closeButton = this.add.text(280, -200, 'X', { fontSize: '32px', fontFamily: '"Poppins", sans-serif', color: '#ff4d4d', backgroundColor: '#fff', padding: { x: 8, y: 2 } }).setOrigin(0.5)
        .setInteractive({ useHandCursor: true }).on('pointerdown', () => this.hideSkillShop());

    this.shopButtons = [];
    SPECIAL_SKILLS.forEach((skill, i) => {
        const y = -130 + i * 70;
        const buttonContainer = this.add.container(0, y);
        const btnBg = this.add.graphics().fillStyle(0x555, 1).fillRoundedRect(-250, -25, 500, 50, 10);
        const icon = this.createSpecialSkillIcon(-210, 0, { skill: skill.id });
        const name = this.add.text(-170, 0, skill.name, { fontSize: '24px', fontFamily: '"Poppins", sans-serif', color: '#fff' }).setOrigin(0, 0.5);
        const cost = this.add.text(200, 0, `Cost: ${skill.cost}`, { fontSize: '24px', fontFamily: '"Poppins", sans-serif', color: '#ffd700' }).setOrigin(1, 0.5);
        buttonContainer.add([btnBg, icon, name, cost]);
        buttonContainer.setSize(500, 50).setInteractive({ useHandCursor: true })
            .on('pointerdown', () => { if (buttonContainer.input.enabled) this.buySkill(skill); })
            .on('pointerover', () => { if (buttonContainer.input.enabled) btnBg.fillStyle(0x777, 1).fillRoundedRect(-250, -25, 500, 50, 10); })
            .on('pointerout', () => { if (buttonContainer.input.enabled) btnBg.fillStyle(0x555, 1).fillRoundedRect(-250, -25, 500, 50, 10); });
        this.shopButtons.push({ button: buttonContainer, skill: skill, bg: btnBg });
    });

    this.skillShopContainer.add([bg, panel, title, closeButton, ...this.shopButtons.map(b => b.button)]);
  }

  showSkillShop(playerNum) {
    if (this.currentPlayer !== playerNum || this.roundOver || this.gameOver || this.attackButton.visible) return;
    this.hideTooltip();
    const currentPoints = (playerNum === 1) ? this.player1SkillPoints : this.player2SkillPoints;
    this.shopButtons.forEach(({ button, skill, bg }) => {
        if (currentPoints >= skill.cost) {
            button.setInteractive({ useHandCursor: true }).setAlpha(1);
            bg.fillStyle(0x555, 1).fillRoundedRect(-250, -25, 500, 50, 10);
        } else {
            button.disableInteractive().setAlpha(0.5);
            bg.fillStyle(0x444, 1).fillRoundedRect(-250, -25, 500, 50, 10);
        }
    });
    this.skillShopContainer.setAlpha(1);
  }

  hideSkillShop() { this.skillShopContainer.setAlpha(0); }

  buySkill(skill) {
    const currentPoints = (this.currentPlayer === 1) ? this.player1SkillPoints : this.player2SkillPoints;
    if (currentPoints < skill.cost) return;

    if (this.currentPlayer === 1) { this.player1SkillPoints -= skill.cost; this.player1PointsText.setText(`Points: ${this.player1SkillPoints.toFixed(1)}`);
    } else { this.player2SkillPoints -= skill.cost; this.player2PointsText.setText(`Points: ${this.player2SkillPoints.toFixed(1)}`); }

    const opponentNum = this.currentPlayer === 1 ? 2 : 1;
    switch(skill.id) {
        case 'attack_boost_10': this.playerBuffs[this.currentPlayer] = { type: 'special_attack_boost' }; this.showBuffMessage('SHOP: ATTACK BOOST!'); if (this.currentPlayer === 1) this.player1BuffText.setText('ATK UP 10% ðŸ”¥').setAlpha(1); else this.player2BuffText.setText('ATK UP 10% ðŸ”¥').setAlpha(1); break;
        case 'heal_40': const healAmount = 40; if (this.currentPlayer === 1) { this.player1HP = Math.min(100, this.player1HP + healAmount); this.updateHpBar(this.player1HPBar, this.player1HP, 100); this.showDamageText(this.player1Sprite.x, this.player1Sprite.y, `+${healAmount}`, '#00ff00'); } else { this.player2HP = Math.min(100, this.player2HP + healAmount); this.updateHpBar(this.player2HPBar, this.player2HP, 100); this.showDamageText(this.player2Sprite.x, this.player2Sprite.y, `+${healAmount}`, '#00ff00'); } this.showBuffMessage('SHOP: RECOVERED 40 HP!'); break;
        case 'block_1': this.playerBuffs[this.currentPlayer] = { type: 'block' }; this.showBuffMessage('SHOP: BLOCK ACTIVATED!'); if (this.currentPlayer === 1) this.player1BuffText.setText('BLOCK ACTIVE ðŸ›¡ï¸').setAlpha(1); else this.player2BuffText.setText('BLOCK ACTIVE ðŸ›¡ï¸').setAlpha(1); break;
        case 'weaken_30': this.playerBuffs[opponentNum] = { type: 'special_weaken' }; this.showBuffMessage("SHOP: OPPONENT WEAKENED!"); if (opponentNum === 1) this.player1BuffText.setText('ATK DOWN 30% ðŸ›¡ï¸').setAlpha(1); else this.player2BuffText.setText('ATK DOWN 30% ðŸ›¡ï¸').setAlpha(1); break;
        case 'combo_guard': this.playerBuffs[this.currentPlayer] = { type: 'combo_guard' }; this.showBuffMessage("SHOP: COMBO GUARD!"); if (this.currentPlayer === 1) this.player1BuffText.setText('COMBO GUARD ðŸ›¡ï¸ðŸ”¥').setAlpha(1); else this.player2BuffText.setText('COMBO GUARD ðŸ›¡ï¸ðŸ”¥').setAlpha(1); break;
    }
    this.hideSkillShop();
  }

  createRobloxAvatar(x, y, playerNum) { const container = this.add.container(x, y); const head = this.add.rectangle(0, -45, 30, 30, 0xfceb00).setStrokeStyle(2, 0x000); const torsoColor = playerNum === 1 ? 0x4169e1 : 0xdc143c; const torso = this.add.rectangle(0, 0, 50, 60, torsoColor).setStrokeStyle(2, 0x000); const leftLeg = this.add.rectangle(-12.5, 60, 25, 60, 0x159143).setStrokeStyle(2, 0x000); const rightLeg = this.add.rectangle(12.5, 60, 25, 60, 0x159143).setStrokeStyle(2, 0x000); container.add([torso, head, leftLeg, rightLeg]); return container; }
  createHpBar(x, y, label) { const bgBar = this.add.graphics().fillStyle(0x333333).fillRect(-100, -15, 200, 30); const healthBar = this.add.graphics().fillStyle(0x00ff00).fillRect(-100, -15, 200, 30); const labelText = this.add.text(0, 0, `100/100`, { fontSize: '18px', fontFamily: '"Poppins", sans-serif', color: '#fff', stroke: '#000', strokeThickness: 2 }).setOrigin(0.5); const nameText = this.add.text(0, -30, label, {fontSize: '22px', fontFamily: '"Poppins", sans-serif', color: '#fff', stroke: '#000', strokeThickness: 3 }).setOrigin(0.5); const container = this.add.container(x, y, [bgBar, healthBar, labelText, nameText]); return { container, bar: healthBar, text: labelText, label }; }
  createActionButton(x, y, text, color, callback) { const button = this.add.text(x, y, text, { fontSize: '28px', fontFamily: '"Poppins", sans-serif', backgroundColor: color, padding: { x: 20, y: 10 }, color: '#fff', stroke: '#000', strokeThickness: 2, fixedWidth: 200, align: 'center' }).setOrigin(0.5).setInteractive({ useHandCursor: true }).on('pointerdown', () => { if (button.input.enabled) { this.tweens.add({ targets: button, scale: 0.95, yoyo: true, duration: 100, ease: 'Power1', onComplete: () => callback.call(this) }); } }).on('pointerover', () => { if (button.input.enabled) this.tweens.add({ targets: button, scale: 1.05, duration: 200, ease: 'Power2' }); }).on('pointerout', () => { if (button.input.enabled) this.tweens.add({ targets: button, scale: 1, duration: 200, ease: 'Power2' }); }); return button; }
  updateHpBar(hpBarData, currentHp, maxHp) { currentHp = Math.max(0, currentHp); const percentage = currentHp / maxHp; hpBarData.bar.clear(); if (percentage < 0.3) hpBarData.bar.fillStyle(0xff0000); else if (percentage < 0.6) hpBarData.bar.fillStyle(0xffa500); else hpBarData.bar.fillStyle(0x00ff00); hpBarData.bar.fillRect(-100, -15, percentage * 200, 30); hpBarData.text.setText(`${Math.round(currentHp)}/${maxHp}`); }
  shuffleArray(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } return array; }

  nextQuestion() {
    if (this.gameOver || this.roundOver) return;
    if (this.questionIndex >= this.shuffledQuestions.length) { this.questionIndex = 0; this.shuffledQuestions = this.shuffleArray([...QUESTIONS]); }
    const q = this.shuffledQuestions[this.questionIndex];
    this.currentQuestion = q;
    
    // Change question background color based on difficulty
    this.questionBg.clear();
    let bgColor = 0xffffff; // Default white
    if (q.difficulty === 'easy') bgColor = 0xc8e6c9; // Light Green
    else if (q.difficulty === 'medium') bgColor = 0xffecb3; // Light Yellow
    else if (q.difficulty === 'hard') bgColor = 0xffcdd2; // Light Red
    this.questionBg.fillStyle(bgColor, 1).fillRoundedRect(20, 410, GAME_WIDTH - 40, 200, 16);
    this.questionBg.lineStyle(4, 0x000000, 1).strokeRoundedRect(20, 410, GAME_WIDTH - 40, 200, 16);

    this.questionText.setText(q.q).setVisible(true);
    for (let i = 0; i < 4; i++) { this.choiceTexts[i].setText(q.choices[i]).setStyle({ backgroundColor: '#4a90e2' }).setInteractive({ useHandCursor: true }).setVisible(true); }
    this.statusText.setText(`${this.currentPlayer === 1 ? this.player1Name : this.player2Name}'s Turn!`);
  }

  onChoice(choiceIdx) {
    if (this.gameOver || this.roundOver || !this.choiceTexts[0].input.enabled) return;
    
    this.roundStats[this.currentPlayer].questionsAnswered++;

    for (let t of this.choiceTexts) t.disableInteractive();
    const correct = (choiceIdx === this.currentQuestion.answer);
    this.showAnswerFeedback(choiceIdx, correct);
    if (correct) {
        this.roundStats[this.currentPlayer].correctAnswers++;
        let points = 0;
        if (this.currentQuestion.difficulty === 'easy') points = 0.5;
        else if (this.currentQuestion.difficulty === 'medium') points = 1.0;
        else if (this.currentQuestion.difficulty === 'hard') points = 1.5;
        
        this.roundStats[this.currentPlayer].pointsEarned += points;

        if(this.currentPlayer === 1) { this.player1SkillPoints += points; this.player1PointsText.setText(`Points: ${this.player1SkillPoints.toFixed(1)}`);
        } else { this.player2SkillPoints += points; this.player2PointsText.setText(`Points: ${this.player2SkillPoints.toFixed(1)}`); }
        const streakCount = this.updateStreak();
        if (streakCount >= this.nextBuffTargets[this.currentPlayer]) {
             this.time.delayedCall(1000, () => { this.applyRandomBuff(); this.time.delayedCall(1500, () => { this.statusText.setText('Correct! Choose your action.'); this.showActionButtons(); }, [], this); }, [], this);
        } else {
             this.time.delayedCall(1000, () => { this.statusText.setText('Correct! Choose your action.'); this.showActionButtons(); }, [], this);
        }
    } else {
        if (this.playerBuffs[this.currentPlayer] && this.playerBuffs[this.currentPlayer].type === 'combo_guard') {
            this.playerBuffs[this.currentPlayer] = null;
            if (this.currentPlayer === 1) this.player1BuffText.setAlpha(0); else this.player2BuffText.setAlpha(0);
            this.showBuffMessage('COMBO GUARD SAVED YOUR STREAK!');
            this.statusText.setText('Wrong, but your combo is safe!');
            this.time.delayedCall(1500, this.switchTurnAndNextQuestion, [], this);
        } else {
            this.resetStreak(this.currentPlayer);
            const nextPlayerName = this.currentPlayer === 1 ? this.player2Name : this.player1Name;
            this.statusText.setText(`Wrong! ${nextPlayerName}'s turn.`);
            this.time.delayedCall(1500, this.switchTurnAndNextQuestion, [], this);
        }
    }
  }

  showAnswerFeedback(choiceIdx, correct) { 
    for (let i = 0; i < 4; i++) { 
        if (i === this.currentQuestion.answer) this.choiceTexts[i].setStyle({ backgroundColor: '#28a745' }); // Correct green
        else if (i === choiceIdx && !correct) this.choiceTexts[i].setStyle({ backgroundColor: '#dc3545' }); // Wrong red
        else this.choiceTexts[i].setStyle({ backgroundColor: '#6c757d' }); // Other choices grey
    } 
  }
  showActionButtons() { if (this.roundOver || this.gameOver) return; this.attackButton.setVisible(true).setInteractive(); this.healButton.setVisible(true).setInteractive(); this.questionText.setVisible(false); this.choiceTexts.forEach(t => t.setVisible(false)); this.updateTurnUI(0); }
  hideActionButtons() { this.attackButton.setVisible(false).disableInteractive(); this.healButton.setVisible(false).disableInteractive(); }

  handleAttack() {
      this.hideActionButtons();
      const targetNum = this.currentPlayer === 1 ? 2 : 1;
      const dmg = this.calculateDamage(this.currentQuestion.difficulty, this.currentPlayer, targetNum);
      
      // Update damage stats
      if (dmg > this.roundStats[this.currentPlayer].maxDamage) this.roundStats[this.currentPlayer].maxDamage = dmg;
      if (dmg > 0 && dmg < this.roundStats[this.currentPlayer].minDamage) this.roundStats[this.currentPlayer].minDamage = dmg;

      let target, attacker, targetHP, hpBar;
      if (this.currentPlayer === 1) { target = this.player2Sprite; attacker = this.player1Sprite; this.player2HP -= dmg; hpBar = this.player2HPBar; targetHP = this.player2HP; } else { target = this.player1Sprite; attacker = this.player2Sprite; this.player1HP -= dmg; hpBar = this.player1HPBar; targetHP = this.player1HP; }
      
      const attackerName = this.currentPlayer === 1 ? this.player1Name : this.player2Name;
      this.statusText.setText(`${attackerName} dealt ${dmg} damage!`);
      this.playAttackAnimation(attacker, target, dmg, '#ff0000');
      this.updateHpBar(hpBar, targetHP, 100);
      this.time.delayedCall(2000, this.switchTurnAndNextQuestion, [], this);
  }

  handleHeal() {
      this.hideActionButtons();
      const healAmount = Phaser.Math.Between(15, 20);
      if (this.currentPlayer === 1) { this.player1HP = Math.min(100, this.player1HP + healAmount); this.updateHpBar(this.player1HPBar, this.player1HP, 100); this.showDamageText(this.player1Sprite.x, this.player1Sprite.y, `+${healAmount}`, '#00ff00'); } else { this.player2HP = Math.min(100, this.player2HP + healAmount); this.updateHpBar(this.player2HPBar, this.player2HP, 100); this.showDamageText(this.player2Sprite.x, this.player2Sprite.y, `+${healAmount}`, '#00ff00'); }
      
      const healerName = this.currentPlayer === 1 ? this.player1Name : this.player2Name;
      this.statusText.setText(`${healerName} healed for ${healAmount}!`);
      this.time.delayedCall(2000, this.switchTurnAndNextQuestion, [], this);
  }

  switchTurnAndNextQuestion() { if (this.roundOver || this.gameOver) return; if (this.player1HP <= 0 || this.player2HP <= 0) { this.endRound(); return; } this.currentPlayer = this.currentPlayer === 1 ? 2 : 1; this.updateTurnUI(this.currentPlayer); this.questionIndex++; this.nextQuestion(); }

  calculateDamage(difficulty, attackerNum, targetNum) {
    if (this.playerBuffs[targetNum] && this.playerBuffs[targetNum].type === 'block') { this.playerBuffs[targetNum] = null; if (targetNum === 1) this.player1BuffText.setAlpha(0); else this.player2BuffText.setAlpha(0); return 0; }
    let baseDmg = 10;
    if (difficulty === 'easy') baseDmg = Phaser.Math.Between(10, 15); else if (difficulty === 'medium') baseDmg = Phaser.Math.Between(18, 25); else if (difficulty === 'hard') baseDmg = Phaser.Math.Between(30, 40);
    if (this.playerBuffs[attackerNum] && this.playerBuffs[attackerNum].type === 'attack_up') { baseDmg *= 1.5; this.playerBuffs[attackerNum] = null; if (attackerNum === 1) this.player1BuffText.setAlpha(0); else this.player2BuffText.setAlpha(0); }
    if (this.playerBuffs[targetNum] && this.playerBuffs[targetNum].type === 'attack_down') { baseDmg *= 0.5; this.playerBuffs[targetNum] = null; if (targetNum === 1) this.player1BuffText.setAlpha(0); else this.player2BuffText.setAlpha(0); }
    if (this.playerBuffs[attackerNum] && this.playerBuffs[attackerNum].type === 'special_attack_boost') { baseDmg *= 1.10; this.playerBuffs[attackerNum] = null; if (attackerNum === 1) this.player1BuffText.setAlpha(0); else this.player2BuffText.setAlpha(0); }
    if (this.playerBuffs[targetNum] && this.playerBuffs[targetNum].type === 'special_weaken') { baseDmg *= 0.70; this.playerBuffs[targetNum] = null; if (targetNum === 1) this.player1BuffText.setAlpha(0); else this.player2BuffText.setAlpha(0); }
    return Math.round(baseDmg);
  }
  
  showImpactEffect(x, y) { const impact = this.add.graphics(); impact.fillStyle(0xffff00, 1); impact.lineStyle(3, 0xffffff, 1); for (let i = 0; i < 8; i++) { const angle = i * 45; const radian = Phaser.Math.DegToRad(angle); impact.slice(x, y, 30, radian - 0.15, radian + 0.15, false).closePath(); } this.tweens.add({ targets: impact, scale: 0, alpha: 0, duration: 400, ease: 'Power2', onComplete: () => impact.destroy() }); }
  playAttackAnimation(attacker, target, damage, color) { if (this.gameOver) return; const originalX = attacker.x; const originalAngle = attacker.angle; const punchAngle = (attacker.x < target.x) ? 25 : -25; this.tweens.chain({ targets: attacker, tweens: [ { x: (target.x + originalX) / 2, angle: punchAngle, duration: 150, ease: 'Power2' }, { duration: 100, onComplete: () => { this.showImpactEffect(target.x, target.y); this.showDamageText(target.x, target.y, (damage > 0 ? `-${damage}`: 'BLOCKED!'), color); this.playDamageShake(target); } }, { x: originalX, angle: originalAngle, duration: 250, ease: 'Power2' } ] }); }
  playDamageShake(target) { this.tweens.add({ targets: target, angle: { from: -5, to: 5 }, duration: 100, yoyo: true, repeat: 2 }); }
  showDamageText(x, y, damageText, color) { const dmgText = this.add.text(x, y - 80, damageText, { fontSize: '32px', color: color, stroke: '#000', strokeThickness: 4, fontFamily: '"Poppins", sans-serif' }).setOrigin(0.5); this.tweens.add({ targets: dmgText, y: y - 160, alpha: 0, duration: 1500, ease: 'Power1', onComplete: () => dmgText.destroy() }); }
  playerStreak(playerNum) { return playerNum === 1 ? this.player1Streak : this.player2Streak; }
  
  updateStreak() {
    let activeStreakText; let streakCount;
    if (this.currentPlayer === 1) { this.player1Streak++; activeStreakText = this.player1StreakText; } else { this.player2Streak++; activeStreakText = this.player2StreakText; }
    streakCount = this.playerStreak(this.currentPlayer);
    if (streakCount > 1) { activeStreakText.setText(`${streakCount} HIT COMBO!`).setAlpha(1); }
    
    if(streakCount > this.roundStats[this.currentPlayer].maxCombo) {
        this.roundStats[this.currentPlayer].maxCombo = streakCount;
    }

    return streakCount;
  }

  resetStreak(playerNum) { if (playerNum === 1) { this.player1Streak = 0; this.player1StreakText.setAlpha(0); this.nextBuffTargets[1] = 3; } else { this.player2Streak = 0; this.player2StreakText.setAlpha(0); this.nextBuffTargets[2] = 3; } }
  showBuffMessage(message) { this.buffText.setText(message).setAlpha(0).setScale(0.5); this.tweens.add({ targets: this.buffText, scale: 1, alpha: 1, duration: 400, ease: 'Power2', yoyo: true, hold: 1000, onComplete: () => this.buffText.setAlpha(0) }); }

  applyRandomBuff() {
      const buffs = ['attack_up', 'heal', 'defense_up']; const randomBuff = Phaser.Utils.Array.GetRandom(buffs); const opponent = this.currentPlayer === 1 ? 2 : 1;
      switch(randomBuff) {
          case 'attack_up': this.playerBuffs[this.currentPlayer] = { type: 'attack_up' }; if (this.currentPlayer === 1) this.player1BuffText.setText('ATK UP ðŸ”¥').setAlpha(1); else this.player2BuffText.setText('ATK UP ðŸ”¥').setAlpha(1); this.showBuffMessage('ATTACK POWER UP!'); break;
          case 'heal': const healAmount = 25; if (this.currentPlayer === 1) { this.player1HP = Math.min(100, this.player1HP + healAmount); this.updateHpBar(this.player1HPBar, this.player1HP, 100); this.showDamageText(this.player1Sprite.x, this.player1Sprite.y, `+${healAmount}`, '#00ff00'); } else { this.player2HP = Math.min(100, this.player2HP + healAmount); this.updateHpBar(this.player2HPBar, this.player2HP, 100); this.showDamageText(this.player2Sprite.x, this.player2Sprite.y, `+${healAmount}`, '#00ff00'); } this.showBuffMessage(`RECOVERED ${healAmount} HP!`); break;
          case 'defense_up': this.playerBuffs[opponent] = { type: 'attack_down' }; if (opponent === 1) this.player1BuffText.setText('ATK DOWN ðŸ›¡ï¸').setAlpha(1); else this.player2BuffText.setText('ATK DOWN ðŸ›¡ï¸').setAlpha(1); this.showBuffMessage("OPPONENT'S ATTACK DOWN!"); break;
      }
      const currentStreak = this.playerStreak(this.currentPlayer); this.nextBuffTargets[this.currentPlayer] = currentStreak + Phaser.Math.Between(2, 4);
  }

  playRobloxDeathAnimation(container, onCompleteCallback) { container.setVisible(false); const parts = container.getAll(); parts.forEach(part => { if (part instanceof Phaser.GameObjects.Rectangle) { const newPart = this.add.rectangle(container.x + part.x, container.y + part.y, part.width, part.height, part.fillColor).setStrokeStyle(part.lineWidth, part.strokeColor); this.tweens.add({ targets: newPart, x: newPart.x + Phaser.Math.Between(-120, 120), y: newPart.y + Phaser.Math.Between(-80, 120), angle: Phaser.Math.Between(-360, 360), alpha: 0, duration: 1200, ease: 'Quad.easeOut', onComplete: () => newPart.destroy() }); } }); this.time.delayedCall(1500, onCompleteCallback, [], this); }

  endRound() {
    this.roundOver = true; 
    this.hideActionButtons();
    this.updateTurnUI(0); // Clear turn indicator
    const roundWinner = this.player1HP <= 0 ? 2 : 1; if (roundWinner === 1) this.player1Score++; else this.player2Score++;
    this.player1ScoreText.setText(`Wins: ${this.player1Score}`); this.player2ScoreText.setText(`Wins: ${this.player2Score}`);
    this.questionText.setVisible(false); this.choiceTexts.forEach(t => t.setVisible(false));
    
    const winnerName = roundWinner === 1 ? this.player1Name : this.player2Name;
    this.statusText.setText(`${winnerName} Wins The Round!`); 
    const loserSprite = roundWinner === 1 ? this.player2Sprite : this.player1Sprite; 
    
    this.playRobloxDeathAnimation(loserSprite, () => { 
        this.updateMatchStats();
        if (this.player1Score >= 2 || this.player2Score >= 2) {
            this.showSummaryScreen('Match Results', this.matchStats, 'Play Again', () => this.scene.restart());
        } else {
            this.showSummaryScreen('Round Clear', this.roundStats, 'Next Round', this.startNextRound);
        }
    });
  }
  
  updateMatchStats() {
    for (let playerNum of [1, 2]) {
        this.matchStats[playerNum].questionsAnswered += this.roundStats[playerNum].questionsAnswered;
        this.matchStats[playerNum].correctAnswers += this.roundStats[playerNum].correctAnswers;
        this.matchStats[playerNum].pointsEarned += this.roundStats[playerNum].pointsEarned;
        if (this.roundStats[playerNum].maxCombo > this.matchStats[playerNum].maxCombo) {
            this.matchStats[playerNum].maxCombo = this.roundStats[playerNum].maxCombo;
        }
        if (this.roundStats[playerNum].maxDamage > this.matchStats[playerNum].maxDamage) {
            this.matchStats[playerNum].maxDamage = this.roundStats[playerNum].maxDamage;
        }
        if (this.roundStats[playerNum].minDamage < this.matchStats[playerNum].minDamage) {
            this.matchStats[playerNum].minDamage = this.roundStats[playerNum].minDamage;
        }
    }
  }
  
  showSummaryScreen(title, stats, buttonText, buttonCallback) {
    this.summaryContainer = this.add.container(GAME_WIDTH / 2, GAME_HEIGHT / 2).setDepth(10).setAlpha(0);
    
    const bg = this.add.graphics().fillStyle(0x000000, 0.7).fillRect(-GAME_WIDTH / 2, -GAME_HEIGHT / 2, GAME_WIDTH, GAME_HEIGHT);
    const panel = this.add.graphics().fillStyle(0x333, 1).fillRoundedRect(-400, -250, 800, 500, 15).lineStyle(3, 0xffffff).strokeRoundedRect(-400, -250, 800, 500, 15);
    
    const titleText = this.make.text({ x: 0, y: -210, text: title, style: { fontSize: '48px', fontFamily: '"Poppins", sans-serif', color: '#fff', stroke: '#000', strokeThickness: 3 } }).setOrigin(0.5);

    // Player 1 Stats
    const p1Title = this.make.text({ x: -200, y: -150, text: this.player1Name, style: { fontSize: '32px', fontFamily: '"Poppins", sans-serif', color: '#4169e1' } }).setOrigin(0.5);
    const p1StatLines = this.createStatLines(-350, -100, stats[1]);
    
    // Player 2 Stats
    const p2Title = this.make.text({ x: 200, y: -150, text: this.player2Name, style: { fontSize: '32px', fontFamily: '"Poppins", sans-serif', color: '#dc143c' } }).setOrigin(0.5);
    const p2StatLines = this.createStatLines(50, -100, stats[2]);

    const nextButton = this.make.text({ x: 0, y: 200, text: buttonText, style: { fontSize: '32px', fontFamily:'"Poppins", sans-serif', backgroundColor: '#4169e1', padding: {x:15, y:10}, color: '#fff', stroke: '#000', strokeThickness: 2 } })
        .setOrigin(0.5).setInteractive({ useHandCursor: true })
        .on('pointerdown', () => buttonCallback.call(this));

    this.summaryContainer.add([bg, panel, titleText, p1Title, p2Title, nextButton, ...p1StatLines, ...p2StatLines]);
    this.tweens.add({ targets: this.summaryContainer, alpha: 1, duration: 500 });
  }
  
  createStatLines(x, y, statData) {
    const lines = [];
    const lineStyle = { fontSize: '22px', fontFamily: '"Poppins", sans-serif', color: '#fff' };
    const valueStyle = { fontSize: '22px', fontFamily: '"Poppins", sans-serif', color: '#ffd700' };
    
    const accuracy = statData.questionsAnswered > 0 ? ((statData.correctAnswers / statData.questionsAnswered) * 100).toFixed(1) : 0;
    const minDamage = statData.minDamage === Infinity ? '0' : statData.minDamage;

    lines.push(this.make.text({ x, y, text: 'Questions Answered:', style: lineStyle }));
    lines.push(this.make.text({ x: x + 300, y, text: `${statData.questionsAnswered}`, style: valueStyle }).setOrigin(1, 0));
    
    lines.push(this.make.text({ x, y: y + 40, text: 'Correct Answers:', style: lineStyle }));
    lines.push(this.make.text({ x: x + 300, y: y + 40, text: `${statData.correctAnswers} (${accuracy}%)`, style: valueStyle }).setOrigin(1, 0));

    lines.push(this.make.text({ x, y: y + 80, text: 'Points Earned:', style: lineStyle }));
    lines.push(this.make.text({ x: x + 300, y: y + 80, text: `${statData.pointsEarned.toFixed(1)}`, style: valueStyle }).setOrigin(1, 0));
    
    lines.push(this.make.text({ x, y: y + 120, text: 'Max Combo:', style: lineStyle }));
    lines.push(this.make.text({ x: x + 300, y: y + 120, text: `${statData.maxCombo}`, style: valueStyle }).setOrigin(1, 0));
    
    lines.push(this.make.text({ x, y: y + 160, text: 'Highest Damage:', style: lineStyle }));
    lines.push(this.make.text({ x: x + 300, y: y + 160, text: `${statData.maxDamage}`, style: valueStyle }).setOrigin(1, 0));
    
    lines.push(this.make.text({ x, y: y + 200, text: 'Lowest Damage:', style: lineStyle }));
    lines.push(this.make.text({ x: x + 300, y: y + 200, text: `${minDamage}`, style: valueStyle }).setOrigin(1, 0));
    
    return lines;
  }

  startNextRound() {
    this.summaryContainer.destroy();
    
    this.roundStats = { 1: this.resetStatsObject(), 2: this.resetStatsObject() };

    this.roundOver = false; this.player1HP = 100; this.player2HP = 100; this.updateHpBar(this.player1HPBar, 100, 100); this.updateHpBar(this.player2HPBar, 100, 100);
    this.player1Sprite.destroy(); this.player2Sprite.destroy();
    this.player1Sprite = this.createRobloxAvatar(250, 320, 1);
    this.player2Sprite = this.createRobloxAvatar(GAME_WIDTH - 250, 320, 2);
    this.player1Streak = 0; this.player2Streak = 0; this.player1StreakText.setAlpha(0); this.player2StreakText.setAlpha(0);
    this.playerBuffs = { 1: null, 2: null }; this.nextBuffTargets = { 1: 3, 2: 3 }; this.player1BuffText.setAlpha(0); this.player2BuffText.setAlpha(0);
    this.updateTurnUI(this.currentPlayer);
    this.questionIndex++; this.nextQuestion();
  }

  // --- ENHANCEMENT: Tooltip functions ---
  createTooltip() {
      const tooltipBg = this.add.graphics();
      const tooltipText = this.add.text(0, 0, '', { fontSize: '16px', fontFamily: '"Poppins", sans-serif', color: '#fff', align: 'center', wordWrap: { width: 180 } }).setOrigin(0.5);
      this.tooltip = this.add.container(0, 0, [tooltipBg, tooltipText]);
      this.tooltip.setData({ bg: tooltipBg, text: tooltipText });
      this.tooltip.setVisible(false).setDepth(20);
  }

  showTooltip(x, y, text) {
      const tooltipText = this.tooltip.getData('text');
      const tooltipBg = this.tooltip.getData('bg');
      
      tooltipText.setText(text);
      const bounds = tooltipText.getBounds();
      
      tooltipBg.clear();
      tooltipBg.fillStyle(0x000000, 0.85);
      tooltipBg.fillRoundedRect(-(bounds.width / 2) - 10, -(bounds.height / 2) - 5, bounds.width + 20, bounds.height + 10, 8);
      
      this.tooltip.setPosition(x, y);
      this.tooltip.setVisible(true);
  }

  hideTooltip() {
      if(this.tooltip) this.tooltip.setVisible(false);
  }

  // --- ENHANCEMENT: Function to manage UI state based on current turn ---
  updateTurnUI(playerNum) {
      if (!this.player1ShopButton) return; // UI not ready yet

      // Player 1 Buttons
      const p1Active = playerNum === 1 && !this.roundOver && !this.gameOver && !this.attackButton.visible;
      this.player1ShopButton.setAlpha(p1Active ? 1 : 0.6).setInteractive(p1Active ? { useHandCursor: true } : false);
      this.player1SkillButtons.forEach((button, index) => {
          const isUsed = this.playerSpecials[1][index].used;
          if (isUsed) return;
          button.setAlpha(p1Active ? 1 : 0.6).setInteractive(p1Active ? { useHandCursor: true } : false);
      });

      // Player 2 Buttons
      const p2Active = playerNum === 2 && !this.roundOver && !this.gameOver && !this.attackButton.visible;
      this.player2ShopButton.setAlpha(p2Active ? 1 : 0.6).setInteractive(p2Active ? { useHandCursor: true } : false);
      this.player2SkillButtons.forEach((button, index) => {
          const isUsed = this.playerSpecials[2][index].used;
          if (isUsed) return;
          button.setAlpha(p2Active ? 1 : 0.6).setInteractive(p2Active ? { useHandCursor: true } : false);
      });

      // Turn Indicator
      if (!this.playerIndicator) {
          this.playerIndicator = this.add.graphics().setDepth(-1);
      }
      this.tweens.killTweensOf(this.playerIndicator);
      this.playerIndicator.clear();

      const activePlayerSprite = playerNum === 1 ? this.player1Sprite : this.player2Sprite;
      if (playerNum > 0 && activePlayerSprite && !this.attackButton.visible) {
          this.playerIndicator.x = activePlayerSprite.x;
          this.playerIndicator.y = activePlayerSprite.y;
          this.playerIndicator.lineStyle(5, 0xffd700, 1);
          this.playerIndicator.strokeRoundedRect(-45, -90, 90, 200, 15);
          this.playerIndicator.setAlpha(1);

          this.tweens.add({
              targets: this.playerIndicator,
              alpha: { from: 1, to: 0.3 },
              scale: { from: 1, to: 1.05 },
              duration: 800,
              yoyo: true,
              repeat: -1,
              ease: 'Sine.easeInOut'
          });
      }
  }
}

const config = { type: Phaser.AUTO, width: GAME_WIDTH, height: GAME_HEIGHT, backgroundColor: '#87ceeb', parent: 'game-container', scene: [MainScene] };
const game = new Phaser.Game(config);

</script>
</body>
</html>






